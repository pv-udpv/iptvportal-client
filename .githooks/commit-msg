#!/bin/bash
# IPTVPortal commit-msg hook
# Validates commit message format and content

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
    echo -e "${RED}❌ $1${NC}"
}

# Get commit message file
COMMIT_MSG_FILE="$1"

# Valid types and scopes
VALID_TYPES="feat|fix|docs|test|refactor|chore|perf|style|ci|revert|build"
VALID_SCOPES="sync|cli|transpiler|schema|cache|config|docs|test|ci|deps|logging"

# Validate conventional commit format (simpler/generic implementation using grep to avoid bash =~ parsing issues)
validate_format() {
    local message="$1"

    # Get first line
    local first_line
    first_line=$(echo "$message" | head -n 1)

    # Allow: type(scope): description  OR  type: description
    if echo "$first_line" | grep -Eq "^(feat|fix|docs|test|refactor|chore|perf|style|ci|revert|build)(\\([a-zA-Z0-9._-]+\\))?:[[:space:]]+"; then
        return 0
    fi

    log_error "Invalid commit message format"
    echo ""
    log_info "Expected format: type(scope): description"
    echo "Valid types: feat, fix, docs, test, refactor, chore, perf, style, ci, revert, build"
    echo "Valid scopes: sync, cli, transpiler, schema, cache, config, docs, test, ci, deps, logging"
    echo ""
    log_info "Examples:"
    echo "  feat(sync): Add incremental sync strategy"
    echo "  fix(cli): Handle invalid command arguments"
    echo "  docs: Update installation guide"
    echo "  test(schema): Add validation tests"
    return 1
}

# Check message length
validate_length() {
    local message="$1"

    # Get first line
    local first_line=$(echo "$message" | head -n 1)

    if [ ${#first_line} -gt 72 ]; then
        log_error "First line too long (${#first_line} chars). Maximum 72 characters."
        log_info "Current: $first_line"
        return 1
    fi

    if [ ${#first_line} -lt 10 ]; then
        log_warning "First line very short (${#first_line} chars). Consider being more descriptive."
    fi

    return 0
}

# Check for issue references
check_issue_reference() {
    local message="$1"
    local branch=$(git branch --show-current)

    # Check if branch name contains issue number
    if [[ $branch =~ issue-([0-9]+) ]]; then
        local issue_num="${BASH_REMATCH[1]}"
        # Use grep for checking message reference to avoid [[ =~ ]] regex parsing issues
        if ! echo "$message" | grep -q "#${issue_num}"; then
            log_warning "Branch '$branch' suggests issue #$issue_num but commit message doesn't reference it"
            log_info "Consider adding 'Closes #$issue_num' or 'Fixes #$issue_num' to the message"
        fi
    fi
}

# Check for WIP commits
check_wip_commits() {
    local message="$1"

    if [[ $message =~ ^(wip|WIP|work in progress|Work in progress) ]]; then
        log_warning "WIP commit detected"
        echo "Do you want to continue with this WIP commit? (y/N)"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Commit cancelled. Remove --no-verify to skip this check."
            exit 1
        fi
    fi
}

# Check for fixup/squash commits on main branch
check_fixup_on_main() {
    local message="$1"
    local branch=$(git branch --show-current)

    if [[ $message =~ ^(fixup|squash)! ]] && [ "$branch" = "main" ]; then
        log_error "Fixup/squash commits not allowed on main branch"
        log_info "Use these commits only for interactive rebasing"
        exit 1
    fi
}

# Check message content
validate_content() {
    local message="$1"

    # Check for empty message
    if [ -z "$(echo "$message" | tr -d '[:space:]')" ]; then
        log_error "Empty commit message"
        exit 1
    fi

    # Check for trailing punctuation
    local first_line=$(echo "$message" | head -n 1)
    if [[ $first_line =~ [.!?]$ ]]; then
        log_warning "First line ends with punctuation. Consider removing it."
    fi

    # Check for all caps
    if [[ $first_line =~ ^[A-Z[:space:]]+$ ]] && [ ${#first_line} -gt 10 ]; then
        log_warning "First line is all caps. Consider using sentence case."
    fi
}

# Parse and validate Cline checklist references
validate_cline_references() {
    local message="$1"

    if [ ! -f ".cline-progress" ]; then
        # No checklist file, skip this check
        return 0
    fi

    # Source the helper functions
    if [ ! -f "scripts/cline-helpers.sh" ]; then
        log_warning "Cline helpers not found, skipping checklist reference validation"
        return 0
    fi

    # Ensure `jq` is available (used by cline helpers). If missing, skip this check.
    if ! command -v jq >/dev/null 2>&1; then
        log_warning "jq not found, skipping checklist reference validation"
        return 0
    fi

    source "scripts/cline-helpers.sh"

    # Look for checklist references in commit message
    # Format: "Completes: #1, #3 (from .cline-progress)"
    local checklist_refs=$(echo "$message" | grep -o "Completes: #[0-9]\+\(,\s*#[0-9]\+\)* (from \.cline-progress)" || true)

    if [ -n "$checklist_refs" ]; then
        log_info "Found checklist references in commit message"

        # Extract item IDs from the reference
        local item_ids=$(echo "$checklist_refs" | grep -o "#[0-9]\+" | sed 's/#//' | tr '\n' ' ')

        # Validate that referenced items exist and are not already completed
        local json_data=$(read_cline_progress)

        for item_id in $item_ids; do
            local item_status=$(echo "$json_data" | jq -r --arg id "$item_id" '.items[] | select(.id == ($id | tonumber)) | .status')
            local item_commit=$(echo "$json_data" | jq -r --arg id "$item_id" '.items[] | select(.id == ($id | tonumber)) | .commit')

            if [ -z "$item_status" ]; then
                log_error "Checklist item #$item_id not found in .cline-progress"
                exit 1
            fi

            if [ "$item_status" = "completed" ] && [ "$item_commit" != "null" ] && [ -n "$item_commit" ]; then
                log_warning "Checklist item #$item_id is already marked as completed with commit $item_commit"
                log_info "This commit will update the reference to the new commit SHA"
            fi
        done

        log_success "Checklist references validated"
    else
        # No checklist references found - check if this commit should reference checklist items
        local branch=$(git branch --show-current)
        if [[ $branch =~ issue- ]]; then
            log_info "Working on issue branch but no checklist references found"
            log_info "Consider adding 'Completes: #X (from .cline-progress)' to link checklist items"
        fi
    fi
}

# Main validation function
validate_commit_message() {
    local message="$1"

    log_info "Validating commit message..."

    if ! validate_format "$message"; then
        exit 1
    fi

    if ! validate_length "$message"; then
        exit 1
    fi

    validate_content "$message"
    check_issue_reference "$message"
    check_wip_commits "$message"
    check_fixup_on_main "$message"
    validate_cline_references "$message"

    log_success "Commit message validation passed"
}

# Main function
main() {
    if [ ! -f "$COMMIT_MSG_FILE" ]; then
        log_error "Commit message file not found: $COMMIT_MSG_FILE"
        exit 1
    fi

    # Read commit message
    local commit_message=$(cat "$COMMIT_MSG_FILE")

    # Skip validation for merge commits
    if echo "$commit_message" | grep -q "^Merge"; then
        log_info "Skipping validation for merge commit"
        exit 0
    fi

    # Skip validation for revert commits
    if echo "$commit_message" | grep -q "^Revert"; then
        log_info "Skipping validation for revert commit"
        exit 0
    fi

    validate_commit_message "$commit_message"
}

# Run main function
main "$@"
