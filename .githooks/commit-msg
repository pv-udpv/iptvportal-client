#!/bin/bash
# IPTVPortal commit-msg hook
# Validates commit message format and content

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
    echo -e "${RED}❌ $1${NC}"
}

# Get commit message file
COMMIT_MSG_FILE="$1"

# Valid types and scopes
VALID_TYPES="feat|fix|docs|test|refactor|chore|perf|style|ci|revert|build"
VALID_SCOPES="sync|cli|transpiler|schema|cache|config|docs|test|ci|deps"

# Validate conventional commit format
validate_format() {
    local message="$1"

    # Check basic format: type(scope): description
    if [[ ! $message =~ ^($VALID_TYPES)(\(($VALID_SCOPES)\))?:[[:space:]] ]]; then
        log_error "Invalid commit message format"
        echo ""
        log_info "Expected format: type(scope): description"
        echo "Valid types: feat, fix, docs, test, refactor, chore, perf, style, ci, revert, build"
        echo "Valid scopes: sync, cli, transpiler, schema, cache, config, docs, test, ci, deps"
        echo ""
        log_info "Examples:"
        echo "  feat(sync): Add incremental sync strategy"
        echo "  fix(cli): Handle invalid command arguments"
        echo "  docs: Update installation guide"
        echo "  test(schema): Add validation tests"
        return 1
    fi

    return 0
}

# Check message length
validate_length() {
    local message="$1"

    # Get first line
    local first_line=$(echo "$message" | head -n 1)

    if [ ${#first_line} -gt 72 ]; then
        log_error "First line too long (${#first_line} chars). Maximum 72 characters."
        log_info "Current: $first_line"
        return 1
    fi

    if [ ${#first_line} -lt 10 ]; then
        log_warning "First line very short (${#first_line} chars). Consider being more descriptive."
    fi

    return 0
}

# Check for issue references
check_issue_reference() {
    local message="$1"
    local branch=$(git branch --show-current)

    # Check if branch name contains issue number
    if [[ $branch =~ issue-([0-9]+) ]]; then
        local issue_num="${BASH_REMATCH[1]}"
        if [[ ! $message =~ #$issue_num ]]; then
            log_warning "Branch '$branch' suggests issue #$issue_num but commit message doesn't reference it"
            log_info "Consider adding 'Closes #$issue_num' or 'Fixes #$issue_num' to the message"
        fi
    fi
}

# Check for WIP commits
check_wip_commits() {
    local message="$1"

    if [[ $message =~ ^(wip|WIP|work in progress|Work in progress) ]]; then
        log_warning "WIP commit detected"
        echo "Do you want to continue with this WIP commit? (y/N)"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Commit cancelled. Remove --no-verify to skip this check."
            exit 1
        fi
    fi
}

# Check for fixup/squash commits on main branch
check_fixup_on_main() {
    local message="$1"
    local branch=$(git branch --show-current)

    if [[ $message =~ ^(fixup|squash)! ]] && [ "$branch" = "main" ]; then
        log_error "Fixup/squash commits not allowed on main branch"
        log_info "Use these commits only for interactive rebasing"
        exit 1
    fi
}

# Check message content
validate_content() {
    local message="$1"

    # Check for empty message
    if [ -z "$(echo "$message" | tr -d '[:space:]')" ]; then
        log_error "Empty commit message"
        exit 1
    fi

    # Check for trailing punctuation
    local first_line=$(echo "$message" | head -n 1)
    if [[ $first_line =~ [.!?]$ ]]; then
        log_warning "First line ends with punctuation. Consider removing it."
    fi

    # Check for all caps
    if [[ $first_line =~ ^[A-Z[:space:]]+$ ]] && [ ${#first_line} -gt 10 ]; then
        log_warning "First line is all caps. Consider using sentence case."
    fi
}

# Main validation function
validate_commit_message() {
    local message="$1"

    log_info "Validating commit message..."

    if ! validate_format "$message"; then
        exit 1
    fi

    if ! validate_length "$message"; then
        exit 1
    fi

    validate_content "$message"
    check_issue_reference "$message"
    check_wip_commits "$message"
    check_fixup_on_main "$message"

    log_success "Commit message validation passed"
}

# Main function
main() {
    if [ ! -f "$COMMIT_MSG_FILE" ]; then
        log_error "Commit message file not found: $COMMIT_MSG_FILE"
        exit 1
    fi

    # Read commit message
    local commit_message=$(cat "$COMMIT_MSG_FILE")

    # Skip validation for merge commits
    if echo "$commit_message" | grep -q "^Merge"; then
        log_info "Skipping validation for merge commit"
        exit 0
    fi

    # Skip validation for revert commits
    if echo "$commit_message" | grep -q "^Revert"; then
        log_info "Skipping validation for revert commit"
        exit 0
    fi

    validate_commit_message "$commit_message"
}

# Run main function
main "$@"
