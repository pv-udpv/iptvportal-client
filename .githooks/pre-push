#!/bin/bash
# IPTVPortal pre-push hook
# Runs comprehensive checks before pushing to remote

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

log_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_error() {
    echo -e "${RED}âŒ $1${NC}"
}

# Get remote and branch info
REMOTE="$1"
BRANCH="$2"

# Check if uv is available
check_uv() {
    if ! command -v uv &> /dev/null; then
        log_error "uv is not available. Please install uv or run outside git hooks."
        exit 1
    fi
}

# Run full test suite
run_full_tests() {
    log_info "Running full test suite..."

    local start_time=$(date +%s)

    if uv run pytest --tb=short; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log_success "All tests passed in ${duration}s"
    else
        log_error "Tests failed. Fix the issues or use --no-verify to skip hooks."
        exit 1
    fi
}

# Check test coverage threshold
check_coverage() {
    log_info "Checking test coverage..."

    # Run coverage if pytest-cov is available
    if uv run pytest --cov=src/iptvportal --cov-report=term-missing --cov-fail-under=80 > /tmp/coverage_output.txt 2>&1; then
        log_success "Coverage check passed"
        # Show coverage summary
        tail -n 5 /tmp/coverage_output.txt | grep -E "(TOTAL|total)" || true
    else
        log_warning "Coverage check failed or below 80%"
        log_info "Coverage report:"
        cat /tmp/coverage_output.txt | tail -n 10
        echo ""
        log_info "Consider adding more tests or use --no-verify to skip this check."
        exit 1
    fi
}

# Check for uncommitted changes
check_uncommitted_changes() {
    if git diff --quiet && git diff --staged --quiet; then
        return 0
    fi

    log_warning "You have uncommitted changes"
    git status --short
    echo ""
    log_info "Consider committing or stashing changes before pushing"
    echo "Do you want to continue anyway? (y/N)"
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        exit 1
    fi
}

# Check if pushing to main branch
check_main_branch_push() {
    if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
        log_warning "Pushing to main branch: $BRANCH"

        # Get commit count since last push
        local commits_since_push=$(git rev-list --count "origin/$BRANCH..$BRANCH" 2>/dev/null || echo "unknown")

        log_info "Commits since last push: $commits_since_push"

        # Check if there are any WIP commits
        local wip_commits=$(git log --oneline "origin/$BRANCH..$BRANCH" 2>/dev/null | grep -i "wip\|work in progress" | wc -l)

        if [ "$wip_commits" -gt 0 ]; then
            log_error "Found $wip_commits WIP commit(s) in main branch push"
            git log --oneline "origin/$BRANCH..$BRANCH" | grep -i "wip\|work in progress"
            log_error "Remove WIP commits from main branch"
            exit 1
        fi

        echo "Are you sure you want to push to main branch? (y/N)"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Push cancelled"
            exit 1
        fi
    fi
}

# Check commit message quality for recent commits
check_recent_commits() {
    log_info "Checking recent commit messages..."

    # Get commits that will be pushed
    local commits_to_push=$(git rev-list "origin/$BRANCH..$BRANCH" 2>/dev/null || git rev-list --all --not --remotes)

    local invalid_commits=()

    for commit in $commits_to_push; do
        local message=$(git log -1 --pretty=%B "$commit" | head -n 1)

        # Skip merge commits
        if [[ $message =~ ^Merge ]]; then
            continue
        fi

        # Check conventional commit format
        local pattern='^(feat|fix|docs|test|refactor|chore|perf|style|ci|revert|build)(\([^)]+\))?:[[:space:]]'
        if [[ ! $message =~ $pattern ]]; then
            invalid_commits+=("$commit: $message")
        fi
    done

    if [ ${#invalid_commits[@]} -gt 0 ]; then
        log_error "Found commits with invalid message format:"
        for commit in "${invalid_commits[@]}"; do
            echo "  $commit"
        done
        log_error "Use conventional commit format: type(scope): description"
        exit 1
    fi

    log_success "All commit messages are valid"
}

# Check for large files in commits to be pushed
check_large_files_in_commits() {
    log_info "Checking for large files in commits to be pushed..."

    local max_size=$((50 * 1024 * 1024))  # 50MB

    # Get files that will be pushed
    local files=$(git diff --name-only "origin/$BRANCH..$BRANCH" 2>/dev/null || git diff --name-only --cached)

    local large_files=()

    for file in $files; do
        if [ -f "$file" ]; then
            local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
            if [ "$size" -gt "$max_size" ]; then
                large_files+=("$file ($(numfmt --to=iec-i --suffix=B $size))")
            fi
        fi
    done

    if [ ${#large_files[@]} -gt 0 ]; then
        log_error "Large files detected in commits to be pushed:"
        for file in "${large_files[@]}"; do
            echo "  $file"
        done
        log_error "Consider using Git LFS for large files"
        exit 1
    fi

    log_success "No large files found in commits"
}

# Check Cline checklist completion before push
check_cline_checklist_completion() {
    if [ ! -f ".cline-progress" ]; then
        # No checklist file, skip this check
        return 0
    fi

    # Source the helper functions
    if [ ! -f "scripts/cline-helpers.sh" ]; then
        log_warning "Cline helpers not found, skipping checklist completion check"
        return 0
    fi

    source "scripts/cline-helpers.sh"

    log_info "Checking Cline checklist completion..."

    local json_data=$(read_cline_progress)
    local total_items=$(echo "$json_data" | jq '.metadata.total_items')
    local completed_items=$(echo "$json_data" | jq '.metadata.completed_items')
    local in_progress_items=$(echo "$json_data" | jq '.metadata.in_progress_items')

    # Check for completed items without commit references
    local invalid_completed=$(echo "$json_data" | jq -r '.items[] | select(.status == "completed" and (.commit == null or .commit == "")) | "\(.id): \(.text)"')

    if [ -n "$invalid_completed" ]; then
        log_error "Found completed checklist items without commit references:"
        echo "$invalid_completed"
        log_error "All completed items must be linked to commits before pushing"
        log_info "Use 'Completes: #X (from .cline-progress)' in commit messages"
        exit 1
    fi

    # Check for critical items that are not completed
    local critical_pending=$(echo "$json_data" | jq -r '.items[] | select(.priority == "critical" and .status != "completed") | "\(.id): \(.text)"')

    if [ -n "$critical_pending" ]; then
        log_error "Found incomplete critical checklist items:"
        echo "$critical_pending"
        log_error "All critical items must be completed before pushing"
        exit 1
    fi

    # Show progress summary
    local progress=$(get_progress_summary)
    log_success "Checklist validation passed: $progress"

    # Warn about in-progress items
    if [ "$in_progress_items" -gt 0 ]; then
        log_warning "Branch has $in_progress_items in-progress checklist items"
        log_info "Consider completing these before merging"
    fi
}

# Show push summary
show_push_summary() {
    local commits_to_push=$(git rev-list --count "origin/$BRANCH..$BRANCH" 2>/dev/null || echo "unknown")
    local files_changed=$(git diff --name-only "origin/$BRANCH..$BRANCH" 2>/dev/null | wc -l)

    echo ""
    log_info "Push Summary:"
    echo "  Remote: $REMOTE"
    echo "  Branch: $BRANCH"
    echo "  Commits: $commits_to_push"
    echo "  Files: $files_changed"
    echo ""
}

# Main function
main() {
    log_info "Running IPTVPortal pre-push checks for $REMOTE/$BRANCH..."

    check_uv
    check_uncommitted_changes
    check_main_branch_push
    check_recent_commits
    check_large_files_in_commits
    check_cline_checklist_completion
    run_full_tests
    check_coverage

    show_push_summary
    log_success "All pre-push checks passed! ðŸš€"
}

# Run main function
main "$@"
