name: Deploy Self-Hosted Runner

on:
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: "Force rebuild Docker image"
        required: false
        type: boolean
        default: false

  push:
    branches:
      - main
    paths:
      - "Dockerfile.runner"
      - "entrypoint.sh"
      - "scripts/install-runner-docker.sh"
      - ".github/workflows/deploy-runner.yml"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate runner registration token (PAT mode)
        if: ${{ secrets.ACTION_RUNNER_TOKEN != '' && (secrets.RUNNER_APP_ID == '' || secrets.RUNNER_APP_PRIVATE_KEY_B64 == '') }}
        id: generate-token
        run: |
          RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.ACTION_RUNNER_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)

          if [ "$HTTP_CODE" != "201" ]; then
            echo "::error::Failed to generate registration token (HTTP $HTTP_CODE)"
            echo "::error::Response: $BODY"
            echo "::error::Check ACTION_RUNNER_TOKEN permissions:"
            echo "::error::  - For fine-grained PAT: 'Administration' permission with 'Read and write' access"
            echo "::error::  - For classic PAT: 'repo' scope"
            echo "::error::  - Token must not be expired"
            exit 1
          fi

          REGISTRATION_TOKEN=$(echo "$BODY" | jq -r '.token')

          if [ -z "$REGISTRATION_TOKEN" ] || [ "$REGISTRATION_TOKEN" = "null" ]; then
            echo "::error::Failed to extract token from response: $BODY"
            exit 1
          fi

          echo "::add-mask::$REGISTRATION_TOKEN"
          echo "token=$REGISTRATION_TOKEN" >> $GITHUB_OUTPUT

      - name: Deploy runner to server (App mode, server-side registration)
        if: ${{ secrets.RUNNER_APP_ID != '' && secrets.RUNNER_APP_PRIVATE_KEY_B64 != '' }}
        uses: appleboy/ssh-action@v1.0.3
        env:
          RUNNER_APP_ID: ${{ secrets.RUNNER_APP_ID }}
          RUNNER_APP_PRIVATE_KEY_B64: ${{ secrets.RUNNER_APP_PRIVATE_KEY_B64 }}
          REPO: ${{ github.repository }}
          RUNNER_NAME: docker-runner-${{ secrets.SERVER_HOSTNAME || 'cargo' }}
          EPHEMERAL: ${{ inputs.ephemeral || 'false' }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: RUNNER_APP_ID,RUNNER_APP_PRIVATE_KEY_B64,REPO,RUNNER_NAME,EPHEMERAL
          script: |
            set -e
            mkdir -p ~/runnerctl && cd ~/runnerctl
            printf '%s' "$RUNNER_APP_PRIVATE_KEY_B64" | base64 -d > app_private_key.pem
            cat > self-runner-ctl.sh << 'EOF'
            #!/usr/bin/env bash
            $(sed 's/\//\\\//g' scripts/self-runner-ctl.sh)
            EOF
            chmod +x self-runner-ctl.sh
            GITHUB_APP_ID="$RUNNER_APP_ID" \
            GITHUB_APP_PRIVATE_KEY_FILE="$HOME/runnerctl/app_private_key.pem" \
            REPO="$REPO" \
            RUNNER_NAME="$RUNNER_NAME" \
            EPHEMERAL="$EPHEMERAL" \
            ./self-runner-ctl.sh

      - name: Deploy runner to server (PAT mode)
        if: ${{ steps.generate-token.outputs.token != '' }}
        uses: appleboy/ssh-action@v1.0.3
        env:
          GITHUB_PAT: ${{ secrets.ACTION_RUNNER_TOKEN }}
          REPO: ${{ github.repository }}
          RUNNER_NAME: docker-runner-${{ secrets.SERVER_HOSTNAME || 'cargo' }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GITHUB_PAT,REPO,RUNNER_NAME
          script: |
            set -e
            mkdir -p ~/runnerctl && cd ~/runnerctl
            cat > self-runner-ctl.sh << 'EOF'
            #!/usr/bin/env bash
            $(sed 's/\//\\\//g' scripts/self-runner-ctl.sh)
            EOF
            chmod +x self-runner-ctl.sh
            REPO="$REPO" RUNNER_NAME="$RUNNER_NAME" GITHUB_PAT="$GITHUB_PAT" ./self-runner-ctl.sh

      - name: Verify runner registration (PAT mode only)
        if: ${{ steps.generate-token.outputs.token != '' }}
        run: |
          echo "Waiting for runner to connect to GitHub..."
          sleep 15

          RUNNERS=$(curl -sS \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.ACTION_RUNNER_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runners")

          RUNNER_NAME="docker-runner-${{ secrets.SERVER_HOSTNAME || 'cargo' }}"
          RUNNER_STATUS=$(echo "$RUNNERS" | jq -r ".runners[] | select(.name == \"$RUNNER_NAME\") | .status")
          RUNNER_BUSY=$(echo "$RUNNERS" | jq -r ".runners[] | select(.name == \"$RUNNER_NAME\") | .busy")

          echo "Runner: $RUNNER_NAME"
          echo "Status: $RUNNER_STATUS"
          echo "Busy: $RUNNER_BUSY"

          if [ "$RUNNER_STATUS" = "online" ]; then
            echo "âœ“ Runner is online and ready"
          else
            echo "::warning::Runner status is '$RUNNER_STATUS'. It may take a few more seconds to come online."
          fi

      - name: Deployment summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## Runner Deployment Summary

          - **Repository**: ${{ github.repository }}
          - **Runner Name**: docker-runner-${{ secrets.SERVER_HOSTNAME || 'cargo' }}
          - **Server**: ${{ secrets.SERVER_HOST }}
          - **Triggered by**: ${{ github.event_name }}

          ### Next Steps

          Check runner status at:
          https://github.com/${{ github.repository }}/settings/actions/runners

          View runner logs:
          ```bash
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}
          docker logs -f gost-runner
          ```
          EOF
